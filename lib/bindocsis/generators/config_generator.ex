defmodule Bindocsis.Generators.ConfigGenerator do
  @moduledoc """
  Generates human-readable DOCSIS configuration format from internal TLV representation.
  
  ## Config Format
  
  Produces human-readable configurations in the following format:
  
  ```
  # DOCSIS Configuration File
  # Generated by Bindocsis
  
  WebAccessControl enabled
  DownstreamFrequency 591000000
  MaxUpstreamTransmitPower 58
  
  DownstreamServiceFlow {
      ServiceFlowReference 1
      ServiceFlowId 2
      QoSParameterSetType 7
  }
  ```
  
  ## Generation Options
  
  - `:include_comments` - Include descriptive comments (default: true)
  - `:include_header` - Include file header comment (default: true)
  - `:indent_size` - Spaces for indentation in compound TLVs (default: 4)
  - `:format_style` - Style format (:standard, :compact) (default: :standard)
  - `:docsis_version` - DOCSIS version for comments (default: "3.1")
  """

  require Logger

  # TLV type to name mapping (reverse of parser mapping)
  @type_to_name %{
    # Basic TLVs (0-20)
    0 => "NetworkAccessControl",
    1 => "DownstreamFrequency", 
    2 => "MaxUpstreamTransmitPower",
    3 => "WebAccessControl",
    4 => "IPAddress",
    5 => "SubnetMask",
    6 => "TFTPServer",
    7 => "SoftwareUpgradeServer",
    8 => "UpstreamChannelID",
    9 => "NTPServer",
    10 => "TimeOffset",
    11 => "UpstreamFrequency",
    12 => "UpstreamSymbolRate",
    13 => "NetworkTime",
    14 => "NetworkAccess",
    15 => "SWUpgradeFilename",
    16 => "SNMPWriteControl",
    17 => "SNMPMibObject",
    18 => "ModemIPAddress",
    19 => "TFTPTimestamp",
    20 => "ModemIPAddress",
    21 => "SoftwareUpgradeFilename",
    
    # Service Flow TLVs (22-26)
    22 => "DownstreamPacketClassification",
    23 => "UpstreamPacketClassification", 
    24 => "DownstreamServiceFlow",
    25 => "UpstreamServiceFlow",
    26 => "PHS",
    
    # Extended TLVs
    36 => "SubscriberManagementCPEIPTable",
    37 => "SubscriberManagementFilters",
    38 => "SnmpV3TrapReceiver",
    39 => "SnmpV3TrapReceiverIP",
    40 => "EnableTestModes",
    41 => "DownstreamChannelList",
    43 => "VendorSpecific"
  }

  # Sub-TLV mappings for compound TLVs
  @subtlv_names %{
    # Service Flow Sub-TLVs
    1 => "ServiceFlowReference",
    2 => "ServiceFlowID", 
    3 => "ServiceClassName",
    6 => "QoSParameterSetType",
    7 => "MaxTrafficRate",
    8 => "MaxTrafficBurst",
    9 => "MinReservedRate",
    10 => "MinReservedPacketSize",
    11 => "ActiveTimeout",
    12 => "AdmittedTimeout",
    14 => "MaxConcatenatedBurst",
    15 => "SchedulingType",
    16 => "RequestTransmissionPolicy",
    17 => "NominalPollInterval",
    18 => "ToleratedPollJitter",
    19 => "IPToS",
    20 => "MaxDownstreamLatency"
  }

  # Value type mappings for proper formatting
  @value_types %{
    0 => :boolean,   # Network Access Control
    1 => :frequency, # Downstream Frequency  
    2 => :power,     # Max Upstream Transmit Power
    3 => :boolean,   # Web Access Control
    4 => :ipv4,      # IP Address
    5 => :ipv4,      # Subnet Mask
    6 => :mac,       # TFTP Server
    7 => :mac,       # Software Upgrade Server
    8 => :integer,   # Upstream Channel ID
    18 => :boolean,  # Max CPE
    24 => :compound, # Downstream Service Flow
    25 => :compound, # Upstream Service Flow
    26 => :compound, # PHS
  }

  @doc """
  Generates config string from TLV representation.
  
  ## Options
  
  - `:include_comments` - Include descriptive comments (default: true)
  - `:include_header` - Include file header (default: true)
  - `:indent_size` - Indent size for compound TLVs (default: 4)
  - `:format_style` - Format style (default: :standard)
  
  ## Examples
  
      iex> tlvs = [%{type: 3, length: 1, value: <<1>>}]
      iex> Bindocsis.Generators.ConfigGenerator.generate(tlvs)
      {:ok, "# DOCSIS Configuration File\\n# Generated by Bindocsis\\n\\nWebAccessControl enabled\\n"}
  """
  @spec generate([map()], keyword()) :: {:ok, String.t()} | {:error, String.t()}
  def generate(tlvs, opts \\ []) when is_list(tlvs) do
    try do
      include_comments = Keyword.get(opts, :include_comments, true)
      include_header = Keyword.get(opts, :include_header, true)
      _indent_size = Keyword.get(opts, :indent_size, 4)
      format_style = Keyword.get(opts, :format_style, :standard)
      docsis_version = Keyword.get(opts, :docsis_version, "3.1")
      
      config_lines = []
      
      # Add header if requested
      config_lines = if include_header do
        header_lines = generate_header(docsis_version, include_comments)
        config_lines ++ header_lines
      else
        config_lines
      end
      
      # Convert each TLV
      tlv_lines = Enum.flat_map(tlvs, fn tlv ->
        convert_tlv_to_config(tlv, opts ++ [indent_level: 0])
      end)
      
      # Combine all lines
      all_lines = config_lines ++ tlv_lines
      
      # Format based on style
      config_string = case format_style do
        :compact -> Enum.join(all_lines, "\n")
        :standard -> format_standard_style(all_lines)
      end
      
      {:ok, config_string}
    rescue
      error ->
        {:error, "Config generation error: #{Exception.message(error)}"}
    end
  end

  @doc """
  Writes TLVs to a config file.
  
  ## Examples
  
      iex> tlvs = [%{type: 3, length: 1, value: <<1>>}]
      iex> Bindocsis.Generators.ConfigGenerator.write_file(tlvs, "config.conf")
      :ok
  """
  @spec write_file([map()], String.t(), keyword()) :: :ok | {:error, String.t()}
  def write_file(tlvs, path, opts \\ []) do
    with {:ok, config_content} <- generate(tlvs, opts),
         :ok <- File.write(path, config_content) do
      :ok
    else
      {:error, reason} when is_atom(reason) ->
        {:error, "File write error: #{reason}"}
      {:error, reason} ->
        {:error, reason}
    end
  end

  # Generate file header
  defp generate_header(docsis_version, include_comments) do
    if include_comments do
      [
        "# DOCSIS Configuration File",
        "# Generated by Bindocsis",
        "# DOCSIS Version: #{docsis_version}",
        "# Generated on: #{DateTime.utc_now() |> DateTime.to_iso8601()}",
        ""
      ]
    else
      [""]
    end
  end

  # Convert a single TLV to config format
  defp convert_tlv_to_config(%{type: type, length: _length, value: value}, opts) do
    include_comments = Keyword.get(opts, :include_comments, true)
    indent_level = Keyword.get(opts, :indent_level, 0)
    indent_size = Keyword.get(opts, :indent_size, 4)
    
    indent = String.duplicate(" ", indent_level * indent_size)
    
    case get_tlv_name(type, indent_level > 0) do
      {:ok, tlv_name} ->
        # Check if this is a compound TLV
        case detect_compound_tlv(type, value) do
          {:ok, subtlvs} ->
            # Generate compound TLV
            generate_compound_tlv(tlv_name, subtlvs, opts)
          
          :not_compound ->
            # Generate simple TLV
            case format_tlv_value(type, value) do
              {:ok, formatted_value} ->
                # Handle empty values
                if formatted_value == "\"\"" and Map.get(@value_types, type) != :raw do
                  ["#{indent}# #{tlv_name} (empty value)"]
                else
                  lines = ["#{indent}#{tlv_name} #{formatted_value}"]
                    
                  if include_comments and indent_level == 0 do
                    comment = get_tlv_comment(type, value)
                    if comment do
                      lines ++ ["#{indent}# #{comment}"]
                    else
                      lines
                    end
                  else
                    lines
                  end
                end
                  
              {:error, _reason} ->
                # Fallback to hex representation
                hex_value = format_as_hex(value)
                ["#{indent}#{tlv_name} #{hex_value}"]

            end
        end
      
      {:error, :unknown} ->
        # Unknown TLV type, use generic format
        hex_value = format_as_hex(value)
        ["#{indent}# Unknown TLV Type #{type}",
         "#{indent}TLV#{type} #{hex_value}"]
    end
  end

  # Get TLV name based on type and context
  defp get_tlv_name(type, is_subtlv) do
    name_map = if is_subtlv, do: @subtlv_names, else: @type_to_name
    
    case Map.get(name_map, type) do
      nil -> {:error, :unknown}
      name -> {:ok, name}
    end
  end

  # Detect if TLV contains subtlvs
  defp detect_compound_tlv(type, value) when byte_size(value) > 2 do
    compound_types = [22, 23, 24, 25, 26, 43]  # Known compound types
    
    if type in compound_types do
      try do
        case Bindocsis.parse_tlv(value, []) do
          tlvs when is_list(tlvs) and length(tlvs) > 0 ->
            {:ok, tlvs}
          _ ->
            :not_compound
        end
      rescue
        _ -> :not_compound
      end
    else
      :not_compound
    end
  end

  defp detect_compound_tlv(_type, _value), do: :not_compound

  # Generate compound TLV with subtlvs
  defp generate_compound_tlv(tlv_name, subtlvs, opts) do
    indent_level = Keyword.get(opts, :indent_level, 0)
    indent_size = Keyword.get(opts, :indent_size, 4)
    
    indent = String.duplicate(" ", indent_level * indent_size)
    
    lines = ["#{indent}#{tlv_name} {"]
    
    # Generate subtlvs with increased indent
    subtlv_opts = Keyword.put(opts, :indent_level, indent_level + 1)
    subtlv_lines = Enum.flat_map(subtlvs, fn subtlv ->
      convert_tlv_to_config(subtlv, subtlv_opts)
    end)
    
    lines = lines ++ subtlv_lines ++ ["#{indent}}"]
    lines
  end

  # Format TLV value based on its type
  defp format_tlv_value(type, value) when is_binary(value) do
    value_type = Map.get(@value_types, type, :raw)
    case format_by_type(value, value_type) do
      {:ok, formatted} -> {:ok, formatted}
      {:error, _} -> 
        # Fallback to hex for problematic values
        {:ok, format_as_hex(value)}
    end
  end

  # Format values based on their semantic type
  defp format_by_type(<<byte>>, :boolean) do
    case byte do
      1 -> {:ok, "enabled"}
      0 -> {:ok, "disabled"}
      _ -> {:ok, "#{byte}"}
    end
  end

  defp format_by_type(<<freq::32>>, :frequency) do
    # Format frequency in Hz
    cond do
      freq >= 1_000_000_000 -> 
        ghz = freq / 1_000_000_000.0
        if ghz == trunc(ghz), do: {:ok, "#{trunc(ghz)}G"}, else: {:ok, "#{ghz}G"}
      freq >= 1_000_000 -> 
        mhz = freq / 1_000_000.0
        if mhz == trunc(mhz), do: {:ok, "#{trunc(mhz)}M"}, else: {:ok, "#{mhz}M"}
      freq >= 1_000 -> 
        khz = freq / 1_000.0
        if khz == trunc(khz), do: {:ok, "#{trunc(khz)}K"}, else: {:ok, "#{khz}K"}
      true -> {:ok, "#{freq}"}
    end
  end

  defp format_by_type(<<power>>, :power) do
    # Convert quarter-dB back to dBmV
    dbmv = power / 4.0
    if dbmv == trunc(dbmv) do
      {:ok, "#{trunc(dbmv)}"}
    else
      {:ok, "#{dbmv}"}
    end
  end

  defp format_by_type(<<a, b, c, d>>, :ipv4) do
    {:ok, "#{a}.#{b}.#{c}.#{d}"}
  end

  defp format_by_type(mac_bytes, :mac) when byte_size(mac_bytes) == 6 do
    hex_string = mac_bytes
    |> :binary.bin_to_list()
    |> Enum.map(&Integer.to_string(&1, 16))
    |> Enum.map(&String.pad_leading(&1, 2, "0"))
    |> Enum.join(":")
    
    {:ok, String.upcase(hex_string)}
  end

  defp format_by_type(value, :integer) when byte_size(value) == 1 do
    <<num>> = value
    {:ok, "#{num}"}
  end

  defp format_by_type(value, :integer) when byte_size(value) == 2 do
    <<num::16>> = value
    {:ok, "#{num}"}
  end

  defp format_by_type(value, :integer) when byte_size(value) == 4 do
    <<num::32>> = value
    {:ok, "#{num}"}
  end

  defp format_by_type(value, :raw) do
    # Try to determine if it's printable text
    cond do
      byte_size(value) == 0 -> {:ok, "\"\""}
      printable_string?(value) -> {:ok, "\"#{value}\""}
      true -> {:ok, format_as_hex(value)}
    end
  end

  defp format_by_type(value, _) when byte_size(value) == 0 do
    {:ok, "\"\""}
  end

  defp format_by_type(value, _) do
    {:ok, format_as_hex(value)}
  end

  # Format binary as hex string
  defp format_as_hex(value) when is_binary(value) do
    value
    |> :binary.bin_to_list()
    |> Enum.map(&Integer.to_string(&1, 16))
    |> Enum.map(&String.pad_leading(&1, 2, "0"))
    |> Enum.join(" ")
    |> String.upcase()
  end

  # Check if binary is printable string
  defp printable_string?(binary) when is_binary(binary) do
    binary
    |> :binary.bin_to_list()
    |> Enum.all?(&printable_char?/1)
  end

  # Check if character is printable
  defp printable_char?(char) when char >= 32 and char <= 126, do: true
  defp printable_char?(char) when char in [9, 10, 13], do: true
  defp printable_char?(_), do: false

  # Get descriptive comment for TLV
  defp get_tlv_comment(type, _value) do
    case type do
      0 -> "Network access control"
      1 -> "Downstream frequency in Hz"
      2 -> "Maximum upstream transmit power in dBmV"
      3 -> "Web-based management access control"
      4 -> "Cable modem IP address"
      5 -> "Subnet mask for cable modem"
      6 -> "TFTP server MAC address"
      7 -> "Software upgrade server MAC address"
      8 -> "Upstream channel ID"
      24 -> "Downstream service flow configuration"
      25 -> "Upstream service flow configuration"
      _ -> nil
    end
  end

  # Format in standard style with proper spacing
  defp format_standard_style(lines) do
    lines
    |> Enum.chunk_by(&(&1 == ""))
    |> Enum.map(&Enum.join(&1, "\n"))
    |> Enum.join("\n\n")
    |> String.trim()
    |> Kernel.<>("\n")
  end

  @doc """
  Validates TLV list before generation.
  
  ## Examples
  
      iex> tlvs = [%{type: 3, length: 1, value: <<1>>}]
      iex> Bindocsis.Generators.ConfigGenerator.validate_tlvs(tlvs)
      :ok
  """
  @spec validate_tlvs([map()]) :: :ok | {:error, String.t()}
  def validate_tlvs(tlvs) when is_list(tlvs) do
    case Enum.find_index(tlvs, &invalid_tlv?/1) do
      nil -> :ok
      index -> {:error, "Invalid TLV at index #{index}"}
    end
  end

  # Check if TLV has required fields
  defp invalid_tlv?(%{type: type, length: length, value: value}) 
    when is_integer(type) and is_integer(length) and is_binary(value) do
    type < 0 or type > 255 or length < 0 or byte_size(value) != length
  end

  defp invalid_tlv?(_), do: true

  @doc """
  Returns supported TLV type names.
  
  ## Examples
  
      iex> names = Bindocsis.Generators.ConfigGenerator.supported_types()
      iex> 3 in Map.keys(names)
      true
  """
  @spec supported_types() :: %{integer() => String.t()}
  def supported_types, do: @type_to_name
end