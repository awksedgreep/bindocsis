defmodule Bindocsis.Generators.ConfigGenerator do
  @moduledoc """
  Generates human-readable DOCSIS configuration format from internal TLV representation.

  ## Config Format

  Produces human-readable configurations in the following format:

  ```
  # DOCSIS Configuration File
  # Generated by Bindocsis

  WebAccessControl enabled
  DownstreamFrequency 591000000
  MaxUpstreamTransmitPower 58

  DownstreamServiceFlow {
      ServiceFlowReference 1
      ServiceFlowId 2
      QoSParameterSetType 7
  }
  ```

  ## Generation Options

  - `:include_comments` - Include descriptive comments (default: true)
  - `:include_header` - Include file header comment (default: true)
  - `:indent_size` - Spaces for indentation in compound TLVs (default: 4)
  - `:format_style` - Style format (:standard, :compact) (default: :standard)
  - `:docsis_version` - DOCSIS version for comments (default: "3.1")
  """

  require Logger

  # DOCSIS TLV type to name mapping
  @docsis_type_to_name %{
    # Basic TLVs (0-20)
    0 => "NetworkAccessControl",
    1 => "DownstreamFrequency",
    2 => "MaxUpstreamTransmitPower",
    3 => "WebAccessControl",
    4 => "IPAddress",
    5 => "SubnetMask",
    6 => "CMMessageIntegrityCheck",
    7 => "SoftwareUpgradeServer",
    8 => "UpstreamChannelID",
    9 => "NTPServer",
    10 => "TimeOffset",
    11 => "UpstreamFrequency",
    12 => "UpstreamSymbolRate",
    13 => "NetworkTime",
    14 => "NetworkAccess",
    15 => "SWUpgradeFilename",
    16 => "SNMPWriteControl",
    17 => "SNMPMibObject",
    18 => "ModemIPAddress",
    19 => "TFTPTimestamp",
    20 => "ModemIPAddress",
    21 => "SoftwareUpgradeFilename",

    # Service Flow TLVs (22-26)
    22 => "DownstreamPacketClassification",
    23 => "UpstreamPacketClassification",
    24 => "DownstreamServiceFlow",
    25 => "UpstreamServiceFlow",
    26 => "PHS",

    # Extended TLVs
    36 => "SubscriberManagementCPEIPTable",
    37 => "SubscriberManagementFilters",
    38 => "SnmpV3TrapReceiver",
    39 => "SnmpV3TrapReceiverIP",
    40 => "EnableTestModes",
    41 => "DownstreamChannelList",
    43 => "VendorSpecific",

    # DOCSIS 3.0/3.1 Extensions (64-85) - conflict with MTA TLVs
    64 => "PacketCableConfiguration",
    65 => "L2VPNMACAgingControl",
    66 => "ManagementEventControl",
    67 => "SubscriberManagementCPEIPv6Table",
    68 => "DefaultUpstreamTargetBuffer",
    69 => "MACAddressLearningControl"
  }

  # PacketCable MTA TLV type to name mapping
  @mta_type_to_name %{
    # Basic TLVs (0-20) - shared with DOCSIS
    0 => "NetworkAccessControl",
    1 => "DownstreamFrequency",
    2 => "UpstreamChannelID",
    3 => "NetworkAccessControl",
    4 => "ClassOfService",
    5 => "ModemCapabilities",
    6 => "CMMIC",
    7 => "CMTSMIC",

    # PacketCable Voice TLVs (64-85)
    64 => "MTAConfigurationFile",
    65 => "VoiceConfiguration",
    66 => "CallSignaling",
    67 => "MediaGateway",
    68 => "SecurityAssociation",
    69 => "KerberosRealm",
    70 => "DNSServer",
    71 => "MTAIPProvisioningMode",
    72 => "ProvisioningTimer",
    73 => "TicketControl",
    74 => "RealmOrganizationName",
    75 => "ProvisioningServer",
    76 => "MTAHardwareVersion",
    77 => "MTASoftwareVersion",
    78 => "MTAMACAddress",
    79 => "SubscriberID",
    80 => "VoiceProfile",
    81 => "EmergencyServices",
    82 => "LawfulIntercept",
    83 => "CallFeatureConfiguration",
    84 => "LinePackage",
    85 => "MTACertificate",
    200 => "VendorSpecific"
  }

  # Sub-TLV mappings for compound TLVs
  @subtlv_names %{
    # Service Flow Sub-TLVs
    1 => "ServiceFlowReference",
    2 => "ServiceFlowID",
    3 => "ServiceClassName",
    6 => "QoSParameterSetType",
    7 => "MaxTrafficRate",
    8 => "MaxTrafficBurst",
    9 => "MinReservedRate",
    10 => "MinReservedPacketSize",
    11 => "ActiveTimeout",
    12 => "AdmittedTimeout",
    14 => "MaxConcatenatedBurst",
    15 => "SchedulingType",
    16 => "RequestTransmissionPolicy",
    17 => "NominalPollInterval",
    18 => "ToleratedPollJitter",
    19 => "IPToS",
    20 => "MaxDownstreamLatency"
  }

  # Value type mappings for proper formatting
  @value_types %{
    # Network Access Control
    0 => :boolean,
    # Downstream Frequency  
    1 => :frequency,
    # Max Upstream Transmit Power
    2 => :power,
    # Web Access Control
    3 => :boolean,
    # IP Address
    4 => :ipv4,
    # Subnet Mask
    5 => :ipv4,
    # CM Message Integrity Check
    6 => :binary,
    # Software Upgrade Server
    7 => :mac,
    # Upstream Channel ID
    8 => :integer,
    # Max CPE
    18 => :boolean,
    # Downstream Service Flow
    24 => :compound,
    # Upstream Service Flow
    25 => :compound,
    # PHS
    26 => :compound
  }

  @doc """
  Generates config string from TLV representation.

  ## Options

  - `:include_comments` - Include descriptive comments (default: true)
  - `:include_header` - Include file header (default: true)
  - `:indent_size` - Indent size for compound TLVs (default: 4)
  - `:format_style` - Format style (default: :standard)
  - `:file_type` - File type hint (:docsis or :mta, auto-detected if not provided)

  ## Examples

      iex> tlvs = [%{type: 3, length: 1, value: <<1>>}]
      iex> Bindocsis.Generators.ConfigGenerator.generate(tlvs)
      {:ok, "# DOCSIS Configuration File\\n# Generated by Bindocsis\\n\\nWebAccessControl enabled\\n"}
  """
  @spec generate([map()], keyword()) :: {:ok, String.t()} | {:error, String.t()}
  def generate(tlvs, opts \\ []) when is_list(tlvs) do
    try do
      include_comments = Keyword.get(opts, :include_comments, true)
      include_header = Keyword.get(opts, :include_header, true)
      _indent_size = Keyword.get(opts, :indent_size, 4)
      format_style = Keyword.get(opts, :format_style, :standard)
      file_type = Keyword.get(opts, :file_type, detect_file_type(tlvs))
      docsis_version = Keyword.get(opts, :docsis_version, "3.1")

      config_lines = []

      # Add header if requested
      config_lines =
        if include_header do
          header_lines = generate_header(file_type, docsis_version, include_comments)
          config_lines ++ header_lines
        else
          config_lines
        end

      # Convert each TLV
      tlv_lines =
        Enum.flat_map(tlvs, fn tlv ->
          convert_tlv_to_config(tlv, opts ++ [indent_level: 0, file_type: file_type])
        end)

      # Combine all lines
      all_lines = config_lines ++ tlv_lines

      # Format based on style
      config_string =
        case format_style do
          :compact -> Enum.join(all_lines, "\n")
          :standard -> format_standard_style(all_lines)
        end

      {:ok, config_string}
    rescue
      error ->
        {:error, "Config generation error: #{Exception.message(error)}"}
    end
  end

  @doc """
  Writes TLVs to a config file.

  ## Examples

      iex> tlvs = [%{type: 3, length: 1, value: <<1>>}]
      iex> Bindocsis.Generators.ConfigGenerator.write_file(tlvs, "config.conf")
      :ok
  """
  @spec write_file([map()], String.t(), keyword()) :: :ok | {:error, String.t()}
  def write_file(tlvs, path, opts \\ []) do
    with {:ok, config_content} <- generate(tlvs, opts),
         :ok <- File.write(path, config_content) do
      :ok
    else
      {:error, reason} when is_atom(reason) ->
        {:error, "File write error: #{reason}"}

      {:error, reason} ->
        {:error, reason}
    end
  end

  # Generate file header
  defp generate_header(file_type, docsis_version, include_comments) do
    if include_comments do
      file_description =
        case file_type do
          :mta -> "PacketCable MTA Configuration File"
          :docsis -> "DOCSIS Configuration File"
          _ -> "DOCSIS Configuration File"
        end

      version_info =
        case file_type do
          :mta -> "PacketCable Version: 2.0"
          :docsis -> "DOCSIS Version: #{docsis_version}"
          _ -> "DOCSIS Version: #{docsis_version}"
        end

      [
        "# #{file_description}",
        "# Generated by Bindocsis",
        "# #{version_info}",
        "# Generated on: #{DateTime.utc_now() |> DateTime.to_iso8601()}",
        ""
      ]
    else
      [""]
    end
  end

  # Convert a single TLV to config format
  defp convert_tlv_to_config(%{type: type, length: _length, value: value}, opts) do
    include_comments = Keyword.get(opts, :include_comments, true)
    indent_level = Keyword.get(opts, :indent_level, 0)
    indent_size = Keyword.get(opts, :indent_size, 4)
    file_type = Keyword.get(opts, :file_type, :docsis)

    indent = String.duplicate(" ", indent_level * indent_size)

    case get_tlv_name(type, indent_level > 0, file_type) do
      {:ok, tlv_name} ->
        # Check if this is a compound TLV
        case detect_compound_tlv(type, value) do
          {:ok, subtlvs} ->
            # Generate compound TLV
            generate_compound_tlv(tlv_name, subtlvs, opts)

          :not_compound ->
            # Generate simple TLV
            {:ok, formatted_value} = format_tlv_value(type, value)
            # Handle empty values
            if formatted_value == "\"\"" and Map.get(@value_types, type) != :raw do
              ["#{indent}# #{tlv_name} (empty value)"]
            else
              lines = ["#{indent}#{tlv_name} #{formatted_value}"]

              if include_comments and indent_level == 0 do
                comment = get_tlv_comment(type, value)

                if comment do
                  lines ++ ["#{indent}# #{comment}"]
                else
                  lines
                end
              else
                lines
              end
            end
        end

      {:error, :unknown} ->
        # Unknown TLV type, use generic format
        hex_value = format_as_hex(value)
        ["#{indent}# Unknown TLV Type #{type}", "#{indent}TLV#{type} #{hex_value}"]
    end
  end

  # Get TLV name based on type and context
  defp get_tlv_name(type, is_subtlv, file_type) do
    name_map =
      cond do
        is_subtlv -> @subtlv_names
        file_type == :mta -> @mta_type_to_name
        true -> @docsis_type_to_name
      end

    case Map.get(name_map, type) do
      nil -> {:error, :unknown}
      name -> {:ok, name}
    end
  end

  # Detect if TLV contains subtlvs
  defp detect_compound_tlv(type, value) when byte_size(value) > 2 do
    # Known compound types
    compound_types = [22, 23, 24, 25, 26, 43]

    if type in compound_types do
      try do
        case Bindocsis.parse_tlv(value, []) do
          tlvs when is_list(tlvs) and length(tlvs) > 0 ->
            {:ok, tlvs}

          _ ->
            :not_compound
        end
      rescue
        _ -> :not_compound
      end
    else
      :not_compound
    end
  end

  defp detect_compound_tlv(_type, _value), do: :not_compound

  # Detect file type based on TLV content
  defp detect_file_type(tlvs) do
    # Look for MTA-specific TLVs (64-85) that indicate PacketCable content
    mta_indicators = [
      64,
      65,
      66,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85
    ]

    has_mta_tlvs =
      Enum.any?(tlvs, fn %{type: type} ->
        type in mta_indicators
      end)

    if has_mta_tlvs do
      :mta
    else
      :docsis
    end
  end

  # Generate compound TLV with subtlvs
  defp generate_compound_tlv(tlv_name, subtlvs, opts) do
    indent_level = Keyword.get(opts, :indent_level, 0)
    indent_size = Keyword.get(opts, :indent_size, 4)

    indent = String.duplicate(" ", indent_level * indent_size)

    lines = ["#{indent}#{tlv_name} {"]

    # Generate subtlvs with increased indent
    subtlv_opts = Keyword.put(opts, :indent_level, indent_level + 1)

    subtlv_lines =
      Enum.flat_map(subtlvs, fn subtlv ->
        convert_tlv_to_config(subtlv, subtlv_opts)
      end)

    lines = lines ++ subtlv_lines ++ ["#{indent}}"]
    lines
  end

  # Format TLV value based on its type
  defp format_tlv_value(type, value) when is_binary(value) do
    value_type = Map.get(@value_types, type, :raw)
    {:ok, formatted} = format_by_type(value, value_type)
    {:ok, formatted}
  end

  # Format values based on their semantic type
  defp format_by_type(<<byte>>, :boolean) do
    case byte do
      1 -> {:ok, "enabled"}
      0 -> {:ok, "disabled"}
      _ -> {:ok, "#{byte}"}
    end
  end

  defp format_by_type(<<freq::32>>, :frequency) do
    # Format frequency in Hz
    cond do
      freq >= 1_000_000_000 ->
        ghz = freq / 1_000_000_000.0
        if ghz == trunc(ghz), do: {:ok, "#{trunc(ghz)}G"}, else: {:ok, "#{ghz}G"}

      freq >= 1_000_000 ->
        mhz = freq / 1_000_000.0
        if mhz == trunc(mhz), do: {:ok, "#{trunc(mhz)}M"}, else: {:ok, "#{mhz}M"}

      freq >= 1_000 ->
        khz = freq / 1_000.0
        if khz == trunc(khz), do: {:ok, "#{trunc(khz)}K"}, else: {:ok, "#{khz}K"}

      true ->
        {:ok, "#{freq}"}
    end
  end

  defp format_by_type(<<power>>, :power) do
    # Convert quarter-dB back to dBmV
    dbmv = power / 4.0

    if dbmv == trunc(dbmv) do
      {:ok, "#{trunc(dbmv)}"}
    else
      {:ok, "#{dbmv}"}
    end
  end

  defp format_by_type(<<a, b, c, d>>, :ipv4) do
    {:ok, "#{a}.#{b}.#{c}.#{d}"}
  end

  defp format_by_type(mac_bytes, :mac) when byte_size(mac_bytes) == 6 do
    hex_string =
      mac_bytes
      |> :binary.bin_to_list()
      |> Enum.map(&Integer.to_string(&1, 16))
      |> Enum.map(&String.pad_leading(&1, 2, "0"))
      |> Enum.join(":")

    {:ok, String.upcase(hex_string)}
  end

  defp format_by_type(value, :integer) when byte_size(value) == 1 do
    <<num>> = value
    {:ok, "#{num}"}
  end

  defp format_by_type(value, :integer) when byte_size(value) == 2 do
    <<num::16>> = value
    {:ok, "#{num}"}
  end

  defp format_by_type(value, :integer) when byte_size(value) == 4 do
    <<num::32>> = value
    {:ok, "#{num}"}
  end

  defp format_by_type(value, :raw) do
    # Try to determine if it's printable text
    cond do
      byte_size(value) == 0 -> {:ok, "\"\""}
      printable_string?(value) -> {:ok, "\"#{value}\""}
      true -> {:ok, format_as_hex(value)}
    end
  end

  defp format_by_type(value, _) when byte_size(value) == 0 do
    {:ok, "\"\""}
  end

  defp format_by_type(value, _) do
    {:ok, format_as_hex(value)}
  end

  # Format binary as hex string
  defp format_as_hex(value) when is_binary(value) do
    value
    |> :binary.bin_to_list()
    |> Enum.map(&Integer.to_string(&1, 16))
    |> Enum.map(&String.pad_leading(&1, 2, "0"))
    |> Enum.join(" ")
    |> String.upcase()
  end

  # Check if binary is printable string
  defp printable_string?(binary) when is_binary(binary) do
    binary
    |> :binary.bin_to_list()
    |> Enum.all?(&printable_char?/1)
  end

  # Check if character is printable
  defp printable_char?(char) when char >= 32 and char <= 126, do: true
  defp printable_char?(char) when char in [9, 10, 13], do: true
  defp printable_char?(_), do: false

  # Get descriptive comment for TLV
  defp get_tlv_comment(type, _value) do
    case type do
      0 -> "Network access control"
      1 -> "Downstream frequency in Hz"
      2 -> "Maximum upstream transmit power in dBmV"
      3 -> "Web-based management access control"
      4 -> "Cable modem IP address"
      5 -> "Subnet mask for cable modem"
      6 -> "TFTP server MAC address"
      7 -> "Software upgrade server MAC address"
      8 -> "Upstream channel ID"
      24 -> "Downstream service flow configuration"
      25 -> "Upstream service flow configuration"
      _ -> nil
    end
  end

  # Format in standard style with proper spacing
  defp format_standard_style(lines) do
    lines
    |> Enum.chunk_by(&(&1 == ""))
    |> Enum.map(&Enum.join(&1, "\n"))
    |> Enum.join("\n\n")
    |> String.trim()
    |> Kernel.<>("\n")
  end

  @doc """
  Validates TLV list before generation.

  ## Examples

      iex> tlvs = [%{type: 3, length: 1, value: <<1>>}]
      iex> Bindocsis.Generators.ConfigGenerator.validate_tlvs(tlvs)
      :ok
  """
  @spec validate_tlvs([map()]) :: :ok | {:error, String.t()}
  def validate_tlvs(tlvs) when is_list(tlvs) do
    case Enum.find_index(tlvs, &invalid_tlv?/1) do
      nil -> :ok
      index -> {:error, "Invalid TLV at index #{index}"}
    end
  end

  # Check if TLV has required fields
  defp invalid_tlv?(%{type: type, length: length, value: value})
       when is_integer(type) and is_integer(length) and is_binary(value) do
    type < 0 or type > 255 or length < 0 or byte_size(value) != length
  end

  defp invalid_tlv?(_), do: true

  @doc """
  Returns supported TLV type names.

  ## Examples

      iex> names = Bindocsis.Generators.ConfigGenerator.supported_types()
      iex> 3 in Map.keys(names)
      true
  """
  @spec supported_types() :: %{integer() => String.t()}
  def supported_types, do: @docsis_type_to_name
end
